<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      学习：通过寻找 MobileIron MDM 上的远程代码执行漏洞黑进 Facebook
    
  </title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="学习：通过寻找 MobileIron MDM 上的远程代码执行漏洞黑进 Facebook" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="整理 MobileIron" />
<meta property="og:description" content="整理 MobileIron" />
<link rel="canonical" href="https://blog.securitainment.io/pentest/2020/09/29/hack-facebook-by-mdm.html" />
<meta property="og:url" content="https://blog.securitainment.io/pentest/2020/09/29/hack-facebook-by-mdm.html" />
<meta property="og:site_name" content="Securitainment.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-29T00:53:00+08:00" />
<script type="application/ld+json">
{"url":"https://blog.securitainment.io/pentest/2020/09/29/hack-facebook-by-mdm.html","dateModified":"2020-09-29T00:53:00+08:00","datePublished":"2020-09-29T00:53:00+08:00","headline":"学习：通过寻找 MobileIron MDM 上的远程代码执行漏洞黑进 Facebook","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.securitainment.io/pentest/2020/09/29/hack-facebook-by-mdm.html"},"description":"整理 MobileIron","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://blog.securitainment.io/feed.xml" title="Securitainment.io" />

  <link rel="shortcut icon" type="image/x-icon" href="/" />
  <link rel="stylesheet" href="https://blog.securitainment.io/assets/css/main.css" />
</head>
<body>
    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <a href="https://blog.securitainment.io"></a>
<h1>学习：通过寻找 MobileIron MDM 上的远程代码执行漏洞黑进 Facebook</h1>
<h2 id="整理-mobileiron">整理 MobileIron</h2>

<p>使用 Google Search 在一个公开网站根目录找到疑似开发商测试用的 RPM 包</p>

<p><img src="https://devco.re/assets/img/blog/20200912/1.png" alt="" /></p>

<p>下载的版本是 2018 年初版。</p>

<p>MobileIron 使用 Java 开发，对外开放 443，8443， 9997 端口，各个端口的功能如下：</p>

<ul>
  <li>443 為使用者裝置註冊介面</li>
  <li>8443 為設備管理介面</li>
  <li>9997 為一個 MobileIron 私有的裝置同步協定 (MI Protocol)</li>
</ul>

<p>三个端口都使用 TLS 保证安全性，网页部分则是通过 Apache Reverse Proxy 架构连接到后端，由 Tomcat 部署的网页应用处理，网页应用由 Spring MVC 开发。</p>

<p><img src="https://devco.re/assets/img/blog/20200912/2.png" alt="" /></p>

<p>由于使用的技术相对较新，传统漏洞如 SQL Injection 比较难从单一的点来发现，因此转向理解程序逻辑，并配合框架层面的攻击。</p>

<h2 id="漏洞总结">漏洞总结</h2>

<p>Web Service 使用了 Hessian 格式处理资料，而产生了反序列化漏洞。</p>

<h2 id="漏洞详解">漏洞详解</h2>

<p>现在已知 MobileIron 在处理 Web Service 的地方存在 Hessian 反序列化漏洞，但是无法直接接触到。</p>

<p>可触发 Hessian 反序列化的路径分别在：</p>

<ul>
  <li>一般使用界面：<code class="language-plaintext highlighter-rouge">https://mobileiron/mifs/services/</code></li>
  <li>管理界面：<code class="language-plaintext highlighter-rouge">https://mobileiron:8443/mifs/services/</code></li>
</ul>

<p>管理界面一般可以轻松接触到 Web Service，但一般用户界面则无法接触到 Web Service，由于一般企业不会将管理页面端口开放在外网，因此只能通过其他方式发现漏洞。</p>

<p>研究 MobileIron 的阻挡方式，发现是通过 Apache 上使用 Rewrite Rules 来阻挡一般用户访问 Web Service：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RewriteRule ^/mifs/services/(.*)$ https://%{SERVER_NAME}:8443/mifs/services/$1 [R=307,L]
RewriteRule ^/mifs/services [F]
</code></pre></div></div>

<p>由于是在前端做的阻挡，联想到 2015 年的研究，针对 Reverse Proxy 架构的新攻击面 <a href="https://blog.orange.tw/2018/08/how-i-chained-4-bugs-features-into-rce-on-amazon.html">Breaking Parser Logic</a>，这个技巧最近也被利用在 <a href="https://support.f5.com/csp/article/K52145254">CVE-2020-5902</a>，F5 BIG-IP TMUI 的远程代码执行漏洞上。</p>

<p>通过 Apache 与 Tomcat 对路径的理解不一致，可以使用以下方式绕过 Rewrite Rule 攻击 Web Service：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://mobileiron/mifs/.;/services/someService
</code></pre></div></div>

<p>这样就可以直接接触到有 Hessian 反序列化存在的 Web Service 了。</p>

<h2 id="利用漏洞">利用漏洞</h2>

<p>针对 Hessian 反序列化，<a href="https://github.com/mbechler">Moritz Bechler</a> 在 <a href="https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf">Java Unmarshaller Security</a> 中做了详细的研究报告，从他开源的 <a href="https://github.com/mbechler/marshalsec">marshalsec</a> 源码中，能学习到 Hessian 在反序列化过程中除了通过 HashMap 触发 <code class="language-plaintext highlighter-rouge">equals()</code> 以及 <code class="language-plaintext highlighter-rouge">hashcode()</code>等，也可以通过 <code class="language-plaintext highlighter-rouge">XString</code> 到 <code class="language-plaintext highlighter-rouge">toString()</code>，而目前关于 Hessian 反序列化已存在的利用链有四条：</p>

<ul>
  <li>Apache XBean</li>
  <li>Caucho Resin</li>
  <li>Spring AOP</li>
  <li>ROME EqualsBean/ToStringBean</li>
</ul>

<p>而根据目标环境，只有 Sprint AOP 这条利用链可以用。</p>

<table>
  <thead>
    <tr>
      <th>–</th>
      <th>Name</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x</td>
      <td>Apache XBean</td>
      <td>JNDI 注入</td>
    </tr>
    <tr>
      <td>x</td>
      <td>Caucho Resin</td>
      <td>JNDI 注入</td>
    </tr>
    <tr>
      <td>√</td>
      <td>Spring AOP</td>
      <td>JNDI 注入</td>
    </tr>
    <tr>
      <td>x</td>
      <td>ROME EqualsBean</td>
      <td>RCE</td>
    </tr>
  </tbody>
</table>

<p>现在有了 JNDI 注入，只要通过 <a href="https://twitter.com/pwntester">Alvaro Muñoz</a> 和 <a href="https://twitter.com/olekmirosh">Oleksandr Mirosh</a> 在 Black Hat USA 2016 上发表的 <a href="https://www.blackhat.com/us-16/briefings.html#a-journey-from-jndi-ldap-manipulation-to-remote-code-execution-dream-land">A Journey From JNDI/LDAP to RCE Dream Land</a> 就可以取得远程命令执行了。</p>

<p>自从 <a href="https://twitter.com/pwntester">Alvaro Muñoz</a> 和 <a href="https://twitter.com/olekmirosh">Oleksandr Mirosh</a> 在 Black Hat 发表了这个新的攻击向量后，帮助了不知道多少黑客，甚至有人认为“遇到反序列化用 JNDI”就对了！，但是自从 2018 年 10 月，Java 把 JNDI 注入的最后一个拼图修复了，这条修复被记录在 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3149">CVE-2018-3149</a> 中，从此以后，所有 Java 版本高于 8u181, 7u191, 6u201 的版本皆无法通过 JNDI/LDAP 的方式执行代码，因此如果要在最新版 MobileIron 上实现攻击，需要另外寻找出路。</p>

<p>关于 CVE-2018-3149，是通过将 <code class="language-plaintext highlighter-rouge">com.sun.jndi.ldap.object.trustURLCodebase</code> 的默认值设置为 <code class="language-plaintext highlighter-rouge">False</code> 的方式以达到禁止攻击者下载远程 Bytecode 执行代码。</p>

<p>但是我们依然可以通过 JNDI 的 Naming Reference 到本机已经有的 Class Factory 上。通过类似 <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-Oriented Programming</a> 的概念，寻找本地可以利用的类别做进一步的利用，详细手法参考 <a href="https://twitter.com/artsploit">Michael Stepankin</a> 在 2019 年年初发表的 <a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java">Exploiting JNDI Injections in Java</a>，里面详细介绍了如何通过 Tomcat 的 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 去载入 <code class="language-plaintext highlighter-rouge">ELProcessor</code> 达到任意代码执行。</p>

<p>但是由于 <code class="language-plaintext highlighter-rouge">ELProcessor</code> 在 Tomcat 8 以后才被引入，但是目标是 Tomcat 7.x，因此需要为 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 寻找一个新的利用链。</p>

<p>经过搜索，发现在 <a href="https://github.com/welk1n">Welkin</a> 的<a href="https://www.cnblogs.com/Welk1n/p/11066397.html">文章</a>中提到：</p>

<blockquote>
  <p>除了 <code class="language-plaintext highlighter-rouge">javax.el.ELProcessor</code>，当然也还有很多其他的类符合条件可以作为 <code class="language-plaintext highlighter-rouge">beanClass</code> 注入到 <code class="language-plaintext highlighter-rouge">BeanFactory</code> 中实现利用。举个例子，如果目标机器 <code class="language-plaintext highlighter-rouge">classpath</code> 中有 <code class="language-plaintext highlighter-rouge">groovy</code> 的库，则可以结合之前 Orange 师傅发过的 <a href="https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html">Jenkins 的漏洞实现利用</a></p>
</blockquote>

<p>目标的 <code class="language-plaintext highlighter-rouge">ClassPath</code> 上刚好有 <code class="language-plaintext highlighter-rouge">Groovy</code> 存在，但是版本为 <code class="language-plaintext highlighter-rouge">1.5.6</code>，是一个距今十年不支持 Meta Programming 的版本，所以最后基于 Groovy 的代码，重新寻找了一个在 <code class="language-plaintext highlighter-rouge">GroovyShell</code> 上的利用链，详细信息参考提交给 <a href="https://github.com/welk1n/JNDI-Injection-Bypass">JNDI-Injection-Bypass</a> 的这个 <a href="https://github.com/welk1n/JNDI-Injection-Bypass/pull/1">Pull Request</a>。</p>

<h2 id="攻击-facebook">攻击 Facebook</h2>

<p>有了基于 <code class="language-plaintext highlighter-rouge">JNDI</code> + <code class="language-plaintext highlighter-rouge">BEANFACTORY</code> + <code class="language-plaintext highlighter-rouge">GROOVYSHELL</code> 的完美远程代码执行漏洞，就可以攻击 Facebook 了。但是检查时发现首页变成了 403 Forbidden，索性 Web Service 还在。</p>

<p>联系到上次的攻击经验，由于安全考虑，Facebook 会禁止所有针对外部的连接，JNDI 注入的核心就是通过受害者连接至攻击者控制的恶意服务器，并接受回传的恶意 Naming Reference 后所导致的一系列利用，无法连接到攻击者的恶意服务器，就没有办法利用。</p>

<p>由此，JNDI 注入的路被全部封杀，只能回到 Hessian 反序列化利用。</p>

<p>为了寻在新的利用链，必须先深入理解已存在的利用链的原理及成因。在重读 <a href="https://github.com/mbechler/marshalsec/blob/master/marshalsec.pdf">Java Unmarshaller Security</a> 的论文后，其中一句话：</p>

<blockquote>
  <p>Cannot restore Groovy’s MethodClosure as readResolve() is called which throws an exception.</p>
</blockquote>

<p>猜想：</p>

<blockquote>
  <p>作者評估過把 Groovy 當成利用鏈的可行性，雖然被限制住了，但一定覺得有機會才會寫進論文中!</p>
</blockquote>

<p>从这个猜想触发，虽然 Groovy 的利用链被 <code class="language-plaintext highlighter-rouge">readResolve()</code> 限制住了，但是目标版本的 Groovy 比较旧，有可能还没进行限制。</p>

<p>比较 Groovy-1.5.6 和最新版本关于 <code class="language-plaintext highlighter-rouge">groovy/runtime/MethodClosure.java</code> 中 <code class="language-plaintext highlighter-rouge">readSolve()</code> 的实现：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>diff 1_5_6/MethodClosure.java 3_0_4/MethodClosure.java

<span class="o">&gt;</span>     private Object readResolve<span class="o">()</span> <span class="o">{</span>
<span class="o">&gt;</span>         <span class="k">if</span> <span class="o">(</span>ALLOW_RESOLVE<span class="o">)</span> <span class="o">{</span>
<span class="o">&gt;</span>             <span class="k">return </span>this<span class="p">;</span>
<span class="o">&gt;</span>         <span class="o">}</span>
<span class="o">&gt;</span>         throw new UnsupportedOperationException<span class="o">()</span><span class="p">;</span>
<span class="o">&gt;</span>     <span class="o">}</span>
</code></pre></div></div>

<p>可以看到旧版没有 <code class="language-plaintext highlighter-rouge">ALLOW_RESOLVE</code> 限制，后来经过查证发现这个限制其实是 Groovy 因为 2015 年出现的 Java 反序列化漏洞而做的缓解措施，而且还被分配了 <a href="https://groovy-lang.org/security.html">CVE-2015-3253</a> 这个漏洞编号。由于 Groovy 只是一个在内部使用，不会对外的小配角，因此没有特别需求下开发者也不会特地去更新，因此这成为了攻击链中的重要一环。</p>

<p>最后攻击成功，取得 Facebook 服务器上的 Shell。</p>

<p><a href="https://youtu.be/hGTLIIOb14A" title="MobileIron MDM unauthenticated REC"><img src="https://img.youtube.com/vi/hGTLIIOb14A/0.jpg" alt="MobileIron MDM unauthenticated REC" /></a></p>
<br/><p>Comments:</p>

<script src="https://utteranc.es/client.js"
        repo="5cr1pt/commnets.blog.securitainment.io"
        issue-term="url"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>
<div style="text-align: center;"><a href='https://blog.securitainment.io'>HOME</a>
</div>
<div style="display:none">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-137221448-1', 'auto');
    ga('send', 'pageview');

  </script>
</div>

        </div>
    </main>

    
    </body>
</html>
